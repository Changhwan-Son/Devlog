---
title: 네트워크 (4) 애플리케이션 구조와 HTTP
date: 2020-11-16 20:11:85
category: Network
thumbnail: { thumbnailSrc }
draft: false
---

## 네트워크 애플리케이션 구조

- 네트워크 구조와 분명히 다르다.
- 애플리케이션 개발자 관점에서 네트워크 구조는 고정되어 있고 애플리케이션에 특정 서비스 집합을 제공
- 애플리케이션 개발자에 의해 설계되고 애플리케이션이 다양한 end-system(종단 시스템)에서 어떻게 조직되어야 하는지를 지시한다.
- 현대 네트워크 애플리케이션은 **두 가지 구조(클라이언트-서버 구조, P2P 구조)** 중 하나로 작성된다.

## 클라이언트-서버 구조 (Client-Server Architecture)

- 항상 켜져 있는 호스트를 **서버**라고 부른다. - 서버는 고정 IP 주소를 갖는다.
- **서버**는 **클라이언트**라는 다른 많은 호스트의 요청을 받는다. - 클라이언트는 서버 주소로 패킷을 보내 서버에 연결할 수 있다.
- 클라이언트는 서로 직접적으로 통신하지 않는다.

## P2P 구조 (peer-to-peer)

- **피어(peer)**라는 연결된 호스트 쌍이 서로 직접 통신
- 피어는 서비스 제공자가 소유하지 않고, 사용자들이 제어하는 데스크탑과 랩탑이다.
- 특정 서버를 통하지 않고 피어가 통신하므로 이 구조를 **피어-투-피어(P2P)**라고 한다.

### 자가 확장성(self-scalability)

- P2P 구조의 가장 주목할만한 특성
- 각 피어들이 서비스를 요청하지만, 다른 피어들에게 제공도 함으로써 그 시스템에 서비스 능력을 추가

# 프로세스간 통신

### 프로세스 : end-system(host)에서 실행되는 프로그램

- 같은 호스트에서 서로 IPC를 통해 통신한다.
- 다른 호스트의 프로세스와는 컴퓨터 네트워크를 통한 **메시지(messages) 교환**으**로 통신

## 소켓(Socket)

- 프로세스는 **소켓(socket)**을 통해 네트워크로 메시지를 보내고 받는다.
- 프로세스를 집(house)라 한다면 소켓은 출입구(door)
- 송신 프로세스는 출입구를 거쳐 메시지를 보낸다. 메시지는 수신 프로세스의 출입문을 거쳐 처리된다.
- 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스

## 프로세스 주소 배정

- 인터넷에서 호스트는 **IP 주소**로 식별된다.
- IP 주소는 32비트로 구성되며, 호스트를 유일하게 식별한다.
- 호스트에서 수행되고 있는 프로세스는 포트 번호로 식별된다.

# 트랜스포트 계층 서비스

## 신뢰적 데이터 전송 (data integrity)

- 안정적인 데이터 전송(no loss, no delay, in-order delivery) 제공
- 몇몇 멀티미디어 애플리케이션은 loss-tolerant (손실 허용) 애플리케이션이다.

## 처리량 (throughput)

- 처리율 : 두 프로세스 간 통신 세션에서 비트를 전달할 수 있는 비율
- 다른 세션들이 네트워크 경로를 따라 대역폭을 공유하고 이 세션들이 생겼다 없어졌다 하기 때문에 가용한 처리율은 시간에 따라 변동이 있음
- (멀티미디어 같은) bandwidth-sensitive application (대역폭 민감 애플리케이션)은 어느정도 보장된 처리율을 갖는 처리율 요구사항을 갖는다.
- elastic application 은 처리율에 상관없이 이용할 수 있다.

## 시간 (timing)

- 트랜스포트 계층 프로토콜은 시간 보장(timing guarantee)을 제공할 수 있다.
- 몇몇 서비스는 효과적으로 동작하기 위해 엄격한 시간 제한 조건을 요구한다.

## 보안 (security)

- 트랜스포트 프로토콜은 애플리케이션에 하나 이상의 보안 서비스 제공
- 암호화, 데이터 무결성, 종단 인증 등

# 인터넷 전송 프로토콜이 제공하는 서비스

인터넷(일반적인 TCP/IP 네트워크)는 애플리케이션에 2가지 전송 프로토콜, **UDP(User Datagram Protocol)** 와 **TCP(Transmission Control Protocol)**를 제공한다. 두 프로토콜은 애플리케이션에 서로 다른 서비스 모델을 제공한다. 

## TCP 서비스

- 연결 지향형 서비스 (connection-oriented)
- **신뢰적인 데이터 전송 (reliable transport)**
- 혼잡 제어 방식 (congestion control) : 네트워크가 혼잡 상태에 이르면 프로세스 속도를 낮춘다.
- 흐름 제어 (flow control) : 전송되는 바이트 스트림이 손실되거나 중복되지 않게함.
- 시간, 최소 처리율 보장, 보안 제공 안함!!

## UDP 서비스

- 비연결형 서비스
- **비신뢰적인 데이터 전송**
- 신뢰성, 흐름,혼잡 제어, 시간, 처리율 보장, 보안 등 제공하지 않음!!

# 웹과 HTTP

## HTTP 개요

웹의 애플리케이션 계층 프로토콜인 **HTTP(HyperText Transfer Protocol)**

- HTTP는 두 가지 프로그램(클라이언트와 서버)로 구현된다.
- 서로 다른 end-system 에서 수행되는 클라이언트 프로그램과 서버 프로그램은 서로 HTTP 메시지를 교환하여 통신한다.

- 웹 페이지는 객체(object)들로 구성된다.
- 객체는 단일 URL로 지정할 수 있는 하나의 파일이다.
- 대부분의 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성된다.
- 각 URL은 객체를 갖고 있는 서버의 호스트 네임과 객체의 경로 이름을 갖고 있다.

  

**www.someschool.edu/someDepartment/picture.gif**

- 호스트 네임 : www.someschool.edu
- 경로 이름 : /someDepartment/picture.gif

## 웹 브라우저

- HTTP의 클라이언트 측 구현
- 요구한 웹 페이지를 보여주고 여러 가지 인터넷 구성 특성 제공

## 웹 서버

- HTTP의 서버 측 구현
- URL로 각각을 지정할 수 있는 웹 객체를 갖고 있다.

## HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다.

- 사용자가 웹 페이지를 요청할 때 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에게 보낸다.
- 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다.

## HTTP는 TCP를 전송 프로토콜로 사용한다.

- HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다.
- 연결되면, 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다.
- 소켓 인터페이스를 통해 HTTP 요청/응답 메시지를 주고 받는다.

## 서버는 클라이언트에 관한 어떠한 상태 정보도 저장하지 않는다.

- HTTP를 stateless protocol(비상태 프로토콜)이라 한다.

## non-persistent HTTP (비지속 연결 HTTP)

- 각 TCP 연결은 하나의 요청 메시지와 응답 메시지만 전송한다.
- 객체를 보낸 후에 각 TCP 연결 끊어짐

## persistent HTTP (지속 연결 HTTP)

- 비지속 연결의 단점 : 각 요청 객체에 대한 새로운 연결이 필요 → 수많은 클라이언트 요청을 동시에 서비스하는 웹 서버에 부담
- 하나의 TCP 연결로 여러 객체 전송 가능

# 사용자와 서버 간 상호 작용 : 쿠키 (cookie)

- 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 제공하기 원해 웹 사이트가 사용자를 확인할 때 사용한다.

## 쿠키(cookie)의 4가지 요소

- HTTP 응답 메시지 쿠키 헤더 라인
- HTTP 요청 메시지 쿠키 헤더 라인
- 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
- 웹 사이트의 백엔드 데이터베이스

# 웹 캐시 Web chche(프록시 서버 proxy server)

- 원출처의 웹 서버(origin Web server)를 대신하여 HTTP 요구를 충족시키는 네트워크 개체
- 웹 개시는 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본이 자기에게 저장되어 있는지 확인한다. 만일 저장되어 있다면 웹 캐시는 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.
3. 만약 웹 캐시가 객체를 가지고 있지 않다면, 웹 캐시는 원출처의 서버로 TCP 연결을 설정한다. 그리고 TCP 연결로 객체에 대한 HTTP 요청을 보낸다. 
4. 웹 캐시가 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보낸다. 

- 캐시는 서버이면서 클라이언트라는 점을 유의해야 한다.
- 브라우저로부터 요구를 받고 응답을 보내는 것은 서버이고, 출처 서버에게 요구를 보내거나 응답을 받는 것이 클라이언트이다.

## 웹 캐시 쓰는 이유

1. 웹 캐시는 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다. 
2. 웹 캐시는 한 기관에서 인터넷으로 접속하는 링크상의 웹 트래픽을 대폭으로 줄일 수 있다.